---
title: 깃(Git) 용어 정리
key: 20181114
ccategories: [git]
tags: [Git, git guide]
redirect_to:
  - https://tech.10000lab.xyz/git/important-git-terms.html
---
## 깃 용어 정리
깃을 사용하다보면 자주 접하는 용어들이 있습니다. 간단한 영어 단어라서 단어 뜻 자체는 어려울게 없으나 깃에서 의미하는 바는 꼭 한번 짚고 넘어갈 만 하죠. 깃이 설치가 될 때 `gitglossary`라는 메뉴얼이 함께 설치가 됩니다. 터미널에서 `man gitglossary`라고 명령어를 치면 언제든지 내용을 볼 수 있고요.

![gitglossary](/assets/images/gitjargon.png)

깃을 사용하면서 자주 접하게될 용어를 하나씩 살펴보겠습니다.
### 브랜치(branch)
개발의 한 갈래라고 말할 수 있겠네요. 깃 리포지토리를 하나 만들고 나면 기본적으로 main이라고 이름 붙여진 브랜치가 하나 생성이 됩니다. main 브랜치 소스 코드를 그대로 둔 상태에서 또는 main 브랜치는 기존 기능의 유지/보수만 하면서 새로운 기능을 추가하려고 한다면 새로운 브랜치를 하나 만드는 것이 그 시작이 되곤하죠. 깃은 브랜치를 자유롭고 편하게 만들 수 있도록 다자인된 시스템입니다. 큰 기능이건 작은 기능이건, 혹은 개인적인 관심사에따른 시험용 코드이건 원할 때마다 브랜치를 만들어도 전혀 문제가 되지 않습니다.

코드를 수정하고 커밋을 하게되면 현재 사용중인 브랜치의 제일 앞에 들어간다고 하는데요. 이 브랜치의 제일 앞쪽 끝을 `브랜치 헤드`라고 부르게 됩니다. 개발이 진행되면서 이 브랜치 헤드는 계속 앞으로 나가게 되죠. 브랜치 헤드가 이동하는 방향을 포워드(forward)라고 합니다. 앞서 말한 것처럼 하나의 리포짓토리에는 다수의 브랜치가 생성이 되는데요. 현재 내가 작업하고 있는 워킹 트리(working tree)는 단 하나의 브랜치에 속해 있겠죠. 바로 현재 사용중인 브랜치라는 의미에서 커런트(current) 브랜치라고도 하고요. 가장 최근 체크아웃을 한 브랜치라서 체크아웃(check out) 브랜치라고도 합니다. 대문자로 헤드 (HEAD)도 바로 커런트 브랜치를 가르키고 있습니다.

### 캐쉬(cache)
현재는 사용하지 않는 용어로 인덱스(index)로 대체되었습니다.

### 체크아웃(checkout)
현재 작업중인 워킹 트리의 일부 혹은 전체를 업데이트 하는 것을 말합니다. 업데이트할 데이터는 깃 로컬 로컬 데이터베이스로부터 트리(폴더)나 블롭(파일)을 불로오게 되는데요. 현재 사용중인 브랜치에서 파일이나 폴더의 일부를 혹은 전체 내용을 데이터베이스에 있는 내용으로 업데이트할 수 있습니다. 이경우 수정중이던 내용이 모두 삭제 되므로 꼭 주의를 해야합니다. 또 하나는 깃 데이터베이스로부터 새로운 브랜치를 블러올 수도 있습니다. 이때는 현재 브랜치의 내용이 새로운 브랜치의 내용으로 업데이트가 되는 거죠.

### 커밋(commit)
명사로서 커밋은 깃에 데이터가 저장되온 히스토리의 한 지점을 말합니다. 팀간의 대화로 보면 '오늘 오전에 내가한 커밋에는 ....' 이런 식으로 사용되죠. 하나의 프로젝트에서 생각해 보면 전체 히스토리는 각 개별 커밋들이 서로 연결되는 과정으로 형성되어 있습니다. 다른 버전 관리 시스템에서 사용하는 용어 중에 리비전(revision), 버전(version)과 같은 의미로 사용한다고 봅니다. 그리고 커밋을 한 오브젝트 자체를 말할 때도 이 말을 사용합니다.

동사로 사용도 되는데요. 커밋을 한다는 것은 현재 프로젝트의 상태를 스냅샷으로 저장하는 행동을 말합니다. 새로 커밋을 한다는 것은 현재의 상태를 나타내는 인덱스를 대표하는 커밋을 생성한다는 것입니다. 그리고 헤드(HEAD)를 그 새로운 커밋을 가르키게 만듭니다.

### 패스트 포워드(fast-forward)
현재 작업중인 브랜치가 있고 다른 브랜치의 내용을 `머지(merge)`하는 경우 발생하는 특별한 머지를 말합니다. 현재 내가 작업중인 브랜치가 master 브랜치에서 어제 생성한 develop 브랜치라고 합시다. 어제부터 develop 브랜치에서 작업을 하고 오늘 master 브랜치에 있는 내용을 머지하려고 합니다. 그런데 master 브랜치에는 develop 브랜치에서 작업한 내용보다 최근 수정한 내용이 포함되어 있어 내가 수정한 내용보다 앞쪽에 속하게 됩니다. 이런 경우 머지커밋(mergecommit)대신에 master 브랜치의 내용을 develop 브랜치에 최근 내용으로 업데이트를 합니다. 이 업데이를 `파스트 포워드`라고 부릅니다.

### 펫치(fetch)
리모트 리포지토리에서 브랜치의 헤드 레프(head ref)를 가져오는 것을 말합니다. 로컬 데이트베이스에 없는 오브젝트가 어떤 것인지 확인을 하고 그 오브젝트를 로컬로 가져옵니다.

### 해시(hash)
깃에서는 오브젝트 이름으로 해시를 사용합니다. `git log` 명령어를 사용하면 커밋 히스토리를 볼 수 있습니다.
```
commit f881ecb53d9ac68631ed9aa97421a8ef192009e5 (HEAD -> master, origin/master)
Author: Ken You <commit@example.com>
Date:   Wed Nov 14 20:54:57 2018 +1100

    add favicon
``` 
첫 줄 'commit'옆에 보이는 암호같은 숫자가 바로 커밋 오브젝트 오브젝트의 해쉬이면서 커밋의 이름이 됩니다.

### 헤드(소문자 head)
브랜치의 제일 앞에 있는 커밋을 가르키는 레퍼런스를 부르는 이름입니다. 헤드는 각 리포짓토리의 `.git/refs/heads/` 폴더에 저장되어 있습니다.

### 헤드(대문자 HEAD)
간단하게 말하면 현재 브랜치를 말합니다. 작업 영역(working tree)은 HEAD에 의해서 지정되는 오브젝트 트리의 상태에서 만들어 집니다. 리포지토리에는 여러개의 브랜치가 있지만 그중에서 현재 체크아웃된 브랜치의 헤드(소문자 head)를 가르킵니다. 하지만 만일 현재 작업 영역이 특정 커밋을 바로 체크아웃한 상태라면 HEAD는 특정 브랜치의 head가 아닌 커밋 그 자체를 가르킵니다.

### 인덱스(index)
변경 내역이 포함된 파일들의 모음입니다. 현재 워킹 트이의 저장된 버전인데요. 여러 버전의 내용을 포함할 수 있습니다. 이 내용은 머지를 할 때 사용하게 됩니다.

### 풀(pull)
브랜치를 풀한다는 것은 브랜치의 내용을 펫치를 한 후 머지를 하는 것을 말압니다.

### 푸시(push)
로컬의 수정 내용을 리모트 리포지토리에 저장하는 것을 말합니다. 우선 리모트 리포지토리에서 헤드가 가르키는 것을 검사합니다. 로컬의 리모트이 내용을 이미 포함한 직접적인 조상인지를 검사합니다. 검사가 통과가 되면 현재 로컬에 있는 변경사항과 새로 생성된 오브젝트를 리모트 리포지토리로 전달합니다. 만일 로컬이 리모트의 적접적인 조상 관계가 없다면 푸시는 실패가 됩니다. 이 경우 리모트 리포지토리를 풀을 한 후 다시 푸시를 하면 성공합니다.

### 리베이스(rebase)
현재 브랜치 처음 생성할 때 어느 특정 커밋(base)에서 시작된 것입니다. 리베이스는 이 베이스를 다시 다른 브랜치의 head로 이동하는 것입니다. 이동을 하게되면 자동으로 현재 브랜치에서 변경된 내역을 새로 변경된 베이스에서 시작된 것으로 커밋을 생성해 줍니다.

---